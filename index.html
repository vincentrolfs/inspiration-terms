<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>Inspiration terms</title>
    <link rel="preconnect" href="https://fonts.gstatic.com"/>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400&display=swap" rel="stylesheet"/>
    <link href="styles/main.css" rel="stylesheet"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
</head>
<body>
<main id="main">
    <h1 id="word"></h1>
</main>

<script>
    function randomFloat(min, max) {
        return Math.random() * (max - min) + min;
    }

    function randomInt(minInclusive, maxExclusive) {
        return Math.floor(randomFloat(minInclusive, maxExclusive));
    }

    // https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve
    function normalDistribution(){
        return Math.sqrt(-2 * Math.log(1 - Math.random())) * Math.cos(2 * Math.PI * Math.random())
    }

    class Rgb {
        constructor(r, g, b) {
            this.r = r ?? this.randomColor();
            this.g = g ?? this.randomColor();
            this.b = b ?? this.randomColor();
        }

        toString() {
            return `rgb(${this.r},${this.g},${this.b})`
        }

        textColor() {
            const K = 20;

            // Calculate the perceptive luminance (aka luma) - human eye favors green color...
            const luma = ((0.299 * this.r) + (0.587 * this.g) + (0.114 * this.b)) / 255;

            if (!fadeColors) {
                return luma > 0.5 ? new Rgb(0, 0, 0) : new Rgb(255, 255, 255)
            }

            // Favor white/black over grey
            const oppLuma = 1 - luma;
            const stretched = Math.atan(K * Math.tan((2 * oppLuma - 1) * Math.PI / 2)) / Math.PI + 0.5;
            const scaled = 255 * stretched

            return new Rgb(scaled, scaled, scaled)
        }

        randomColor() {
            return randomFloat(0, 255)
        }

        interpolate(otherColor, strength) {
            strength = Math.max(0, Math.min(1, strength || 0))

            const r = strength * otherColor.r + (1 - strength) * this.r
            const g = strength * otherColor.g + (1 - strength) * this.g
            const b = strength * otherColor.b + (1 - strength) * this.b

            return new Rgb(r, g, b)
        }
    }
</script>

<script>
    const UPDATE_RATE = 50;

    const params = new URL(location.href).searchParams;
    const terms = (params.get("terms") || "inspiration,terms").split(",");
    const delayLow = (parseInt(params.get("delayLow")) || 10);
    const delayHigh = (parseInt(params.get("delayHigh")) || delayLow);
    const fadeWindow = (parseFloat(params.get("fadeWindow")) || 0.1);
    const fadeColors = null === params.get("noFade");
    const useNormalDistribution = null !== params.get("useNormalDistribution");
</script>

<script>
    class Changer {
        currentIndex;
        currentDelay;
        timeSinceChange;
        currentColor;
        nextColor;

        performChange() {
            const newIndex = this.computeNewIndex();
            const newDelay = this.computeNewDelay();
            const newColor = new Rgb();

            this.applyChange(newIndex, newDelay, newColor)
        }

        applyChange(newIndex, newDelay, newColor) {
            console.log({newIndex, newDelay, newColor: newColor.toString()})

            this.currentIndex = newIndex;
            this.currentDelay = newDelay;
            this.timeSinceChange = 0;
            this.currentColor = this.nextColor || new Rgb();
            this.nextColor = newColor;

            document.getElementById('word').innerText = terms[this.currentIndex];

            this.applyInstantColors();
        }

        computeNewIndex() {
            let newIndex;

            do {
                newIndex = randomInt(0, terms.length);
            } while (newIndex === this.currentIndex || terms.length <= 1);

            return newIndex;
        }

        computeNewDelay() {
            if (!useNormalDistribution){
                return 1000 * Math.abs(randomFloat(delayLow, delayHigh))
            }

            const stdDv = 1000 * (delayHigh - delayLow) / 2
            const mean = 1000 * (delayLow + delayHigh) / 2

            return Math.abs(stdDv * normalDistribution() + mean)
        }


        applyFadingColors() {
            if (!fadeColors) {
                return;
            }

            if (this.timeSinceChange < (1 - fadeWindow) * this.currentDelay) {
                return this.applyColors(this.currentColor)
            }

            const fadeTimeSoFar = this.timeSinceChange - (1 - fadeWindow) * this.currentDelay;
            const fadeTimeTotal = fadeWindow * this.currentDelay;

            this.applyColors(
                this.currentColor.interpolate(this.nextColor, fadeTimeSoFar / fadeTimeTotal)
            )
        }

        applyInstantColors() {
            if (fadeColors) {
                return;
            }

            this.applyColors(this.nextColor)
        }

        applyColors(effectiveColor) {
            document.getElementById('main').style.backgroundColor = effectiveColor.toString();
            document.getElementById('word').style.color = effectiveColor.textColor().toString();
        }

        run() {
            this.performChange();

            setInterval(() => {
                this.timeSinceChange += UPDATE_RATE;

                this.applyFadingColors();

                if (this.timeSinceChange >= this.currentDelay) {
                    this.performChange();
                }
            }, UPDATE_RATE);
        }
    }

    new Changer().run()
</script>

<footer>
    <span>Created by <a href="https://vincentrolfs.github.io/">Vincent Rolfs</a></span>
</footer>
</body>
</html>